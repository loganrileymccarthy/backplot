import React, { useRef, useEffect, useCallback } from 'react';

// 3D Vector utilities
class Vec3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  add(v) {
    return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
  }

  subtract(v) {
    return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
  }

  multiply(scalar) {
    return new Vec3(this.x * scalar, this.y * scalar, this.z * scalar);
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }

  cross(v) {
    return new Vec3(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
  }

  normalize() {
    const len = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    if (len === 0) return new Vec3(0, 0, 0);
    return new Vec3(this.x / len, this.y / len, this.z / len);
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
}

// 4x4 Matrix for transformations
class Mat4 {
  constructor() {
    this.m = new Array(16).fill(0);
    this.identity();
  }

  identity() {
    this.m = [
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ];
    return this;
  }

  multiply(other) {
    const result = new Mat4();
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        result.m[i * 4 + j] = 0;
        for (let k = 0; k < 4; k++) {
          result.m[i * 4 + j] += this.m[i * 4 + k] * other.m[k * 4 + j];
        }
      }
    }
    return result;
  }

  translate(x, y, z) {
    const t = new Mat4();
    t.m[12] = x;
    t.m[13] = y;
    t.m[14] = z;
    return this.multiply(t);
  }

  rotateX(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const r = new Mat4();
    r.m[5] = c;
    r.m[6] = -s;
    r.m[9] = s;
    r.m[10] = c;
    return this.multiply(r);
  }

  rotateY(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const r = new Mat4();
    r.m[0] = c;
    r.m[2] = s;
    r.m[8] = -s;
    r.m[10] = c;
    return this.multiply(r);
  }

  rotateZ(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const r = new Mat4();
    r.m[0] = c;
    r.m[1] = -s;
    r.m[4] = s;
    r.m[5] = c;
    return this.multiply(r);
  }

  scale(x, y, z) {
    const s = new Mat4();
    s.m[0] = x;
    s.m[5] = y;
    s.m[10] = z;
    return this.multiply(s);
  }

  transformPoint(point) {
    const x = point.x * this.m[0] + point.y * this.m[4] + point.z * this.m[8] + this.m[12];
    const y = point.x * this.m[1] + point.y * this.m[5] + point.z * this.m[9] + this.m[13];
    const z = point.x * this.m[2] + point.y * this.m[6] + point.z * this.m[10] + this.m[14];
    const w = point.x * this.m[3] + point.y * this.m[7] + point.z * this.m[11] + this.m[15];
    return new Vec3(x / w, y / w, z / w);
  }
}

// 3D Object class
class Object3D {
  constructor(vertices = [], faces = []) {
    this.vertices = vertices;
    this.faces = faces;
    this.position = new Vec3(0, 0, 0);
    this.rotation = new Vec3(0, 0, 0);
    this.scale = new Vec3(1, 1, 1);
    this.color = '#ffffff';
    this.wireframe = false;
  }

  getTransformMatrix() {
    return new Mat4()
      .translate(this.position.x, this.position.y, this.position.z)
      .rotateX(this.rotation.x)
      .rotateY(this.rotation.y)
      .rotateZ(this.rotation.z)
      .scale(this.scale.x, this.scale.y, this.scale.z);
  }
}

// Predefined 3D shapes
export const createCube = (size = 1) => {
  const s = size / 2;
  const vertices = [
    new Vec3(-s, -s, -s), new Vec3(s, -s, -s), new Vec3(s, s, -s), new Vec3(-s, s, -s),
    new Vec3(-s, -s, s), new Vec3(s, -s, s), new Vec3(s, s, s), new Vec3(-s, s, s)
  ];
  
  const faces = [
    [0, 1, 2, 3], [4, 7, 6, 5], [0, 4, 5, 1], [2, 6, 7, 3], [0, 3, 7, 4], [1, 5, 6, 2]
  ];
  
  return new Object3D(vertices, faces);
};

export const createSphere = (radius = 1, segments = 16) => {
  const vertices = [];
  const faces = [];
  
  for (let i = 0; i <= segments; i++) {
    const lat = (i * Math.PI) / segments;
    for (let j = 0; j <= segments; j++) {
      const lng = (j * 2 * Math.PI) / segments;
      const x = radius * Math.sin(lat) * Math.cos(lng);
      const y = radius * Math.cos(lat);
      const z = radius * Math.sin(lat) * Math.sin(lng);
      vertices.push(new Vec3(x, y, z));
    }
  }
  
  for (let i = 0; i < segments; i++) {
    for (let j = 0; j < segments; j++) {
      const a = i * (segments + 1) + j;
      const b = a + segments + 1;
      faces.push([a, b, b + 1, a + 1]);
    }
  }
  
  return new Object3D(vertices, faces);
};

export const createPyramid = (size = 1) => {
  const s = size / 2;
  const vertices = [
    new Vec3(0, s, 0),
    new Vec3(-s, -s, -s),
    new Vec3(s, -s, -s),
    new Vec3(s, -s, s),
    new Vec3(-s, -s, s)
  ];
  
  const faces = [
    [1, 2, 3, 4], // base
    [0, 1, 2],    // sides
    [0, 2, 3],
    [0, 3, 4],
    [0, 4, 1]
  ];
  
  return new Object3D(vertices, faces);
};

// Camera class
class Camera {
  constructor(fov = 60, aspect = 1, near = 0.1, far = 1000) {
    this.position = new Vec3(0, 0, 5);
    this.target = new Vec3(0, 0, 0);
    this.up = new Vec3(0, 1, 0);
    this.fov = fov;
    this.aspect = aspect;
    this.near = near;
    this.far = far;
  }

  getViewMatrix() {
    const z = this.position.subtract(this.target).normalize();
    const x = this.up.cross(z).normalize();
    const y = z.cross(x);
    
    const view = new Mat4();
    view.m[0] = x.x; view.m[4] = x.y; view.m[8] = x.z; view.m[12] = -x.dot(this.position);
    view.m[1] = y.x; view.m[5] = y.y; view.m[9] = y.z; view.m[13] = -y.dot(this.position);
    view.m[2] = z.x; view.m[6] = z.y; view.m[10] = z.z; view.m[14] = -z.dot(this.position);
    view.m[3] = 0; view.m[7] = 0; view.m[11] = 0; view.m[15] = 1;
    
    return view;
  }

  getProjectionMatrix(width, height) {
    const aspect = width / height;
    const f = 1 / Math.tan((this.fov * Math.PI / 180) / 2);
    const proj = new Mat4();
    
    proj.m[0] = f / aspect;
    proj.m[5] = f;
    proj.m[10] = (this.far + this.near) / (this.near - this.far);
    proj.m[11] = -1;
    proj.m[14] = (2 * this.far * this.near) / (this.near - this.far);
    proj.m[15] = 0;
    
    return proj;
  }
}

// Renderer class
class Renderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.width = canvas.width;
    this.height = canvas.height;
    this.camera = new Camera();
    this.objects = [];
    this.backgroundColor = '#000000';
    this.enableBackfaceCulling = true;
    this.lightDirection = new Vec3(0, 0, 1).normalize();
  }

  addObject(object) {
    this.objects.push(object);
  }

  removeObject(object) {
    const index = this.objects.indexOf(object);
    if (index > -1) {
      this.objects.splice(index, 1);
    }
  }

  clear() {
    this.objects = [];
  }

  projectPoint(point) {
    const viewMatrix = this.camera.getViewMatrix();
    const projMatrix = this.camera.getProjectionMatrix(this.width, this.height);
    
    const viewPoint = viewMatrix.transformPoint(point);
    const projPoint = projMatrix.transformPoint(viewPoint);
    
    const x = (projPoint.x + 1) * this.width / 2;
    const y = (1 - projPoint.y) * this.height / 2;
    
    return { x, y, z: viewPoint.z };
  }

  calculateFaceNormal(face, transformedVertices) {
    if (face.length < 3) return new Vec3(0, 0, 1);
    
    const v1 = transformedVertices[face[1]].subtract(transformedVertices[face[0]]);
    const v2 = transformedVertices[face[2]].subtract(transformedVertices[face[0]]);
    
    return v1.cross(v2).normalize();
  }

  render() {
    this.ctx.fillStyle = this.backgroundColor;
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    const renderData = [];
    
    for (const obj of this.objects) {
      const transform = obj.getTransformMatrix();
      const transformedVertices = obj.vertices.map(v => transform.transformPoint(v));
      const projectedVertices = transformedVertices.map(v => this.projectPoint(v));
      
      for (const face of obj.faces) {
        const normal = this.calculateFaceNormal(face, transformedVertices);
        
        if (this.enableBackfaceCulling && normal.z <= 0) continue;
        
        const avgZ = face.reduce((sum, i) => sum + projectedVertices[i].z, 0) / face.length;
        const lighting = Math.max(0.2, normal.dot(this.lightDirection));
        
        renderData.push({
          face,
          projectedVertices,
          avgZ,
          color: obj.color,
          wireframe: obj.wireframe,
          lighting
        });
      }
    }
    
    renderData.sort((a, b) => b.avgZ - a.avgZ);
    
    for (const data of renderData) {
      this.drawFace(data);
    }
  }

  drawFace({ face, projectedVertices, color, wireframe, lighting }) {
    if (face.length === 0) return;
    
    this.ctx.beginPath();
    this.ctx.moveTo(projectedVertices[face[0]].x, projectedVertices[face[0]].y);
    
    for (let i = 1; i < face.length; i++) {
      this.ctx.lineTo(projectedVertices[face[i]].x, projectedVertices[face[i]].y);
    }
    this.ctx.closePath();
    
    if (!wireframe) {
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      
      this.ctx.fillStyle = `rgb(${Math.floor(r * lighting)}, ${Math.floor(g * lighting)}, ${Math.floor(b * lighting)})`;
      this.ctx.fill();
    }
    
    this.ctx.strokeStyle = wireframe ? color : '#333333';
    this.ctx.lineWidth = wireframe ? 2 : 0.5;
    this.ctx.stroke();
  }
}

// Main Canvas3D Component
export const Canvas3D = ({ 
  width = 800, 
  height = 600, 
  backgroundColor = '#000000',
  enableBackfaceCulling = true,
  lightDirection = { x: 0, y: 0, z: 1 },
  camera = {},
  children,
  onRender,
  ...props 
}) => {
  const canvasRef = useRef(null);
  const rendererRef = useRef(null);
  const animationRef = useRef(null);

  const render = useCallback(() => {
    if (rendererRef.current) {
      rendererRef.current.render();
      if (onRender) onRender(rendererRef.current);
    }
  }, [onRender]);

  const animate = useCallback(() => {
    render();
    animationRef.current = requestAnimationFrame(animate);
  }, [render]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    canvas.width = width;
    canvas.height = height;

    const renderer = new Renderer(canvas);
    renderer.backgroundColor = backgroundColor;
    renderer.enableBackfaceCulling = enableBackfaceCulling;
    renderer.lightDirection = new Vec3(lightDirection.x, lightDirection.y, lightDirection.z).normalize();

    if (camera.position) {
      renderer.camera.position = new Vec3(camera.position.x, camera.position.y, camera.position.z);
    }
    if (camera.target) {
      renderer.camera.target = new Vec3(camera.target.x, camera.target.y, camera.target.z);
    }
    if (camera.fov) {
      renderer.camera.fov = camera.fov;
    }

    rendererRef.current = renderer;

    animate();

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [width, height, backgroundColor, enableBackfaceCulling, lightDirection, camera, animate]);

  return (
    <canvas
      ref={canvasRef}
      width={width}
      height={height}
      style={{ border: '1px solid #333', display: 'block' }}
      {...props}
    />
  );
};

// Hook for managing 3D objects
export const use3DScene = () => {
  const rendererRef = useRef(null);

  const addObject = useCallback((object) => {
    if (rendererRef.current) {
      rendererRef.current.addObject(object);
    }
  }, []);

  const removeObject = useCallback((object) => {
    if (rendererRef.current) {
      rendererRef.current.removeObject(object);
    }
  }, []);

  const clear = useCallback(() => {
    if (rendererRef.current) {
      rendererRef.current.clear();
    }
  }, []);

  const setRenderer = useCallback((renderer) => {
    rendererRef.current = renderer;
  }, []);

  return {
    addObject,
    removeObject,
    clear,
    setRenderer,
    renderer: rendererRef.current
  };
};

// Export utilities
export { Vec3, Mat4, Object3D, Camera, Renderer };

// Usage example:
/*
import { Canvas3D, createCube, createSphere, use3DScene } from './Canvas3D';

function App() {
  const scene = use3DScene();
  
  useEffect(() => {
    const cube = createCube(2);
    cube.position = new Vec3(-2, 0, 0);
    cube.color = '#ff0000';
    
    const sphere = createSphere(1, 20);
    sphere.position = new Vec3(2, 0, 0);
    sphere.color = '#00ff00';
    
    scene.addObject(cube);
    scene.addObject(sphere);
    
    const animate = () => {
      cube.rotation.y += 0.01;
      sphere.rotation.x += 0.01;
      requestAnimationFrame(animate);
    };
    animate();
  }, [scene]);

  return (
    <Canvas3D
      width={800}
      height={600}
      camera={{ position: { x: 0, y: 0, z: 8 } }}
      onRender={(renderer) => scene.setRenderer(renderer)}
    />
  );
}
*/
